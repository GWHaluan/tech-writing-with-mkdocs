{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Technical Writing with mkdocs Hello! I am a Technical Writer specializing in software documentation and I am using Markdown and mkdocs to create my user documentation and API documentation. On this github pages space, I want to write about tricks and methods that I discovered to improve mkdocs.","title":"Home"},{"location":"#technical-writing-with-mkdocs","text":"Hello! I am a Technical Writer specializing in software documentation and I am using Markdown and mkdocs to create my user documentation and API documentation. On this github pages space, I want to write about tricks and methods that I discovered to improve mkdocs.","title":"Technical Writing with mkdocs"},{"location":"config/","text":"Setup and Configuration git Install git . mkdocs Install mkdocs . mkdocs is written in Python. First, install Python , then download get-pip . Execute the following command in the directory with get-pip : python get-pip.py Afterwards, install mkdocs via pip: pip install mkdocs In Ubuntu Linux, you need to take extra steps to install the latest versions of python and pip. See this tutorial for an installation of Python 3.7. A Stack Overflow post provides some additional tricks . It is best to keep a 3.7 -suffix for pip, so the references are unambiguous: user@machine:~/Desktop$ python --version Python 2.7.15rc1 user@machine:~/Desktop$ python3.7 --version Python 3.7.0 user@machine:~/Desktop$ pip --version pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) user@machine:~/Desktop$ pip3.7 --version pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) In this case, pip is only installed in Python 3.7. Theme There are a couple of themes for mkdocs. I prefer Material , as it offers the most polished look and feel. Install it via pip: pip install mkdocs-material Activate the Material theme via your mkdocs.yml file: theme : name : material Note Material overrides the built-in search bar, which has been greatly improved with regard to performance in the 1.0.0 Milestone release of mkdocs. In very large projects, this can cause the frontend to freeze for a several seconds which is unacceptable UX. Styling While your theme dictates a general look and feel, you can style your documentation page in a number of ways. Include css files via your mkdocs.yml file: extra_css : - stylesheets/css.css Set a favicon and logo via your theme in your mkdocs.yml file: theme : name : material logo : favicon.ico favicon : favicon.ico Comments Sadly, Markdown does not provide a syntax for comments. There is a somewhat dirty workaround with comments in link syntax with empty link text, for example: [](This comment cannot be seen because there is no link text) You can also just use html comments: !-- A comment -- This comment will be visible in the page source when you convert to html though. The cleanest implementation for Markdown comments is the Markdown extension mkdcomments . Install it via pip: pip install git+https://github.com/ryneeverett/python-markdown-comments.git Activate it via your mkdocs.yml file: markdown_extensions : - mkdcomments Now you can use html comments with a slight modification (three dashes instead of two), and they will not appear in the page source when you convert to html: !--- A comment -- Includes Sadly, Markdown does not provide a syntax to include a partial or the entire content of other Markdown files. Luckily, there is a Markdown extension for it: Markdon-Include . Install it with: pip install git+https://github.com/ryneeverett/python-markdown-comments.git Activate it via your mkdocs.yml file: markdown_extensions : - markdown_include.include Note that the .include suffix is necessary. Reference other Markdown files like this: !path/to/filename.md! but wrapped in { and } . Note that you can set a base URL for include paths: markdown_extensions : - markdown_include.include : base_path : docs This base path will be prefixed to paths you set for includes. If there are broken links, a warning will appear on your mkdocs build or mkdocs serve console output: WARNING - Documentation file config.md contains a link to deadlink.md which is not found in the documentation files. However, you cannot configure mkdocs to fail its build or serve in case of a warning, as the use of strict mode would do. The source code uses a print statement for the warning in the except block of the run function. My recommendation for an error exit upon broken links would be to: clone the repository override the except block like so: except Exception as e: print( Warning: could not find file {}. Ignoring include statement. Error: {} .format(filename, e)) lines[loc] = INC_SYNTAX.sub( ,line) raise e i.e., rather than using a break statement, raise the exception and cause an error. install markdown locally via: pip install -e . in the directory where you modified the cloned include extension. You might as well host the fork, e.g. in bitbucket, and install it from there. Code Highlighting There is an extension for code highlighting that works beautifully with the Material theme: codehilite . Activate it via your mkdocs.yml file: markdown_extensions : - codehilite ToC Permalinks To enable Permalinks for your page headlines, use the toc extension and add the following snippet to your mkdocs.yml file: markdown_extensions : - toc : permalink : True Next to each headline, a paragraph symbol will appear upon hover, and act as an anchor URL to the section. When you click it, you can copy the link from your browser address bar. There is a problem with the toc extension: Anchor links are generated from headlines, and specifically from the headline strings. However, they are language-specific. In case you want to translate your project, translating any headlines other than first level, will break any incoming links to their sections. There is a workaround, refer to my idea for translation post-processing . Mermaid Diagrams With mermaid diagrams , you can create certain types of schematic images via a simple syntax and maintain the image source code directly within your Markdown files. mermaid is written in Javascript, and thus you can include its script file in your mkdocs.yml file: extra_javascript : - https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js or just download the minified version and include it in your project: extra_javascript : - scripts/mermaid.min.js You can now embed a graph definition in a div -tag with class attribute mermaid in your Markdown files like so: div class= mermaid graph LR Start -- Stop /div mermaidjs will convert this to a graph: graph LR Start -- Stop In order to use the fenced code macro ``` mermaid instead of html tags, you need to customize a Markdown extension called pymdownx . Add the following to your mkdocs.yml file: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_div_format Check out gilbsgilbs' post here .","title":"Setup and Configuration"},{"location":"config/#setup-and-configuration","text":"","title":"Setup and Configuration"},{"location":"config/#git","text":"Install git .","title":"git"},{"location":"config/#mkdocs","text":"Install mkdocs . mkdocs is written in Python. First, install Python , then download get-pip . Execute the following command in the directory with get-pip : python get-pip.py Afterwards, install mkdocs via pip: pip install mkdocs In Ubuntu Linux, you need to take extra steps to install the latest versions of python and pip. See this tutorial for an installation of Python 3.7. A Stack Overflow post provides some additional tricks . It is best to keep a 3.7 -suffix for pip, so the references are unambiguous: user@machine:~/Desktop$ python --version Python 2.7.15rc1 user@machine:~/Desktop$ python3.7 --version Python 3.7.0 user@machine:~/Desktop$ pip --version pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) user@machine:~/Desktop$ pip3.7 --version pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) In this case, pip is only installed in Python 3.7.","title":"mkdocs"},{"location":"config/#theme","text":"There are a couple of themes for mkdocs. I prefer Material , as it offers the most polished look and feel. Install it via pip: pip install mkdocs-material Activate the Material theme via your mkdocs.yml file: theme : name : material Note Material overrides the built-in search bar, which has been greatly improved with regard to performance in the 1.0.0 Milestone release of mkdocs. In very large projects, this can cause the frontend to freeze for a several seconds which is unacceptable UX.","title":"Theme"},{"location":"config/#styling","text":"While your theme dictates a general look and feel, you can style your documentation page in a number of ways. Include css files via your mkdocs.yml file: extra_css : - stylesheets/css.css Set a favicon and logo via your theme in your mkdocs.yml file: theme : name : material logo : favicon.ico favicon : favicon.ico","title":"Styling"},{"location":"config/#comments","text":"Sadly, Markdown does not provide a syntax for comments. There is a somewhat dirty workaround with comments in link syntax with empty link text, for example: [](This comment cannot be seen because there is no link text) You can also just use html comments: !-- A comment -- This comment will be visible in the page source when you convert to html though. The cleanest implementation for Markdown comments is the Markdown extension mkdcomments . Install it via pip: pip install git+https://github.com/ryneeverett/python-markdown-comments.git Activate it via your mkdocs.yml file: markdown_extensions : - mkdcomments Now you can use html comments with a slight modification (three dashes instead of two), and they will not appear in the page source when you convert to html: !--- A comment --","title":"Comments"},{"location":"config/#includes","text":"Sadly, Markdown does not provide a syntax to include a partial or the entire content of other Markdown files. Luckily, there is a Markdown extension for it: Markdon-Include . Install it with: pip install git+https://github.com/ryneeverett/python-markdown-comments.git Activate it via your mkdocs.yml file: markdown_extensions : - markdown_include.include Note that the .include suffix is necessary. Reference other Markdown files like this: !path/to/filename.md! but wrapped in { and } . Note that you can set a base URL for include paths: markdown_extensions : - markdown_include.include : base_path : docs This base path will be prefixed to paths you set for includes. If there are broken links, a warning will appear on your mkdocs build or mkdocs serve console output: WARNING - Documentation file config.md contains a link to deadlink.md which is not found in the documentation files. However, you cannot configure mkdocs to fail its build or serve in case of a warning, as the use of strict mode would do. The source code uses a print statement for the warning in the except block of the run function. My recommendation for an error exit upon broken links would be to: clone the repository override the except block like so: except Exception as e: print( Warning: could not find file {}. Ignoring include statement. Error: {} .format(filename, e)) lines[loc] = INC_SYNTAX.sub( ,line) raise e i.e., rather than using a break statement, raise the exception and cause an error. install markdown locally via: pip install -e . in the directory where you modified the cloned include extension. You might as well host the fork, e.g. in bitbucket, and install it from there.","title":"Includes"},{"location":"config/#code-highlighting","text":"There is an extension for code highlighting that works beautifully with the Material theme: codehilite . Activate it via your mkdocs.yml file: markdown_extensions : - codehilite","title":"Code Highlighting"},{"location":"config/#toc-permalinks","text":"To enable Permalinks for your page headlines, use the toc extension and add the following snippet to your mkdocs.yml file: markdown_extensions : - toc : permalink : True Next to each headline, a paragraph symbol will appear upon hover, and act as an anchor URL to the section. When you click it, you can copy the link from your browser address bar. There is a problem with the toc extension: Anchor links are generated from headlines, and specifically from the headline strings. However, they are language-specific. In case you want to translate your project, translating any headlines other than first level, will break any incoming links to their sections. There is a workaround, refer to my idea for translation post-processing .","title":"ToC Permalinks"},{"location":"config/#mermaid-diagrams","text":"With mermaid diagrams , you can create certain types of schematic images via a simple syntax and maintain the image source code directly within your Markdown files. mermaid is written in Javascript, and thus you can include its script file in your mkdocs.yml file: extra_javascript : - https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js or just download the minified version and include it in your project: extra_javascript : - scripts/mermaid.min.js You can now embed a graph definition in a div -tag with class attribute mermaid in your Markdown files like so: div class= mermaid graph LR Start -- Stop /div mermaidjs will convert this to a graph: graph LR Start -- Stop In order to use the fenced code macro ``` mermaid instead of html tags, you need to customize a Markdown extension called pymdownx . Add the following to your mkdocs.yml file: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_div_format Check out gilbsgilbs' post here .","title":"Mermaid Diagrams"},{"location":"link/","text":"Link Checking mkdocs does not come with integrated link checking. In a living documentation, file names as well as section titles are going to change on a regular basis. Every time that happens, any links to those files or section titles inevitably break and need to be fixed. Thus it would be nice to have an automated process that detects these broken links so you do not have to search for them yourself. The solution sketched below uses a recursive wget command that can be run during a build process. wget GNU Wget is a program that retrieves web content. It can be utilized as a link checker because it will return a 404 if it cannot follow links when invoked recursively. Take for example this broken link (relative Markdown link to non-existing.md ). Now, if you invoke wget like so: wget --recursive --no-verbose --spider -e robots=off https://gwhaluan.github.io/tech-writing-with-mkdocs/ you get the following output on your console (or at least got, at the time of this writing): 2018 -12-04 13 :19:24 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/ [ 9609 /9609 ] - gwhaluan.github.io/tech-writing-with-mkdocs/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:24 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/favicon.ico 200 OK unlink: No such file or directory 2018 -12-04 13 :19:24 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/stylesheets/application.451f80e5.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/assets/stylesheets/application.451f80e5.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/javascripts/modernizr.1aa3b519.js 200 OK unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/fonts/material-icons.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/assets/fonts/material-icons.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/stylesheets/hal.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/stylesheets/hal.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/why/ [ 20913 /20913 ] - gwhaluan.github.io/tech-writing-with-mkdocs/why/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/config/ [ 27062 /27062 ] - gwhaluan.github.io/tech-writing-with-mkdocs/config/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/workflow/ [ 12263 /12263 ] - gwhaluan.github.io/tech-writing-with-mkdocs/workflow/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/nav/ [ 26665 /26665 ] - gwhaluan.github.io/tech-writing-with-mkdocs/nav/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/link/ [ 11841 /11841 ] - gwhaluan.github.io/tech-writing-with-mkdocs/link/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/tlpostproc/ [ 9361 /9361 ] - gwhaluan.github.io/tech-writing-with-mkdocs/tlpostproc/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/javascripts/application.583bbe55.js 200 OK unlink: No such file or directory 2018 -12-04 13 :19:26 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/scripts/mermaid.min.js 200 OK unlink: No such file or directory https://gwhaluan.github.io/tech-writing-with-mkdocs/link/non-existing.md: Remote file does not exist -- broken link!!! Found 1 broken link. https://gwhaluan.github.io/tech-writing-with-mkdocs/link/non-existing.md FINISHED --2018-12-04 13 :19:26-- Total wall clock time: 2 ,5s Downloaded: 7 files, 115K in 0 ,03s ( 3 ,62 MB/s ) wget needs to be invoked recursively to make it follow any links it discovers during parsing of page contents. The --spider parameter prevents wget from downloading the pages and just behave like a webspider. Note that this causes the log lines prefixed with unlink: , since wget still assumes that there are downloaded files. If we do not exclude the lookup of a robots.txt file with -e robots=off , we get another error 404. Pipeline You can always run this command locally, but then you would have to do it every time before or after you deploy your changes. Ideally, it would be integrated into the deployment process or be part of your quality control. For instance, wget can be run inside a docker task and even fail your build if there are broken links. In order to not clutter your log, you can hack wget a little via: 2 gt; amp;1 | grep -B 1 ERROR 404 amp; amp; exit 1 || exit 0 This will redirect your stderr also to your stdout, pipe it into grep, looking through it for the string \"ERROR 404\" and then either exit in an error state or not.","title":"Solved: Link Checking"},{"location":"link/#link-checking","text":"mkdocs does not come with integrated link checking. In a living documentation, file names as well as section titles are going to change on a regular basis. Every time that happens, any links to those files or section titles inevitably break and need to be fixed. Thus it would be nice to have an automated process that detects these broken links so you do not have to search for them yourself. The solution sketched below uses a recursive wget command that can be run during a build process.","title":"Link Checking"},{"location":"link/#wget","text":"GNU Wget is a program that retrieves web content. It can be utilized as a link checker because it will return a 404 if it cannot follow links when invoked recursively. Take for example this broken link (relative Markdown link to non-existing.md ). Now, if you invoke wget like so: wget --recursive --no-verbose --spider -e robots=off https://gwhaluan.github.io/tech-writing-with-mkdocs/ you get the following output on your console (or at least got, at the time of this writing): 2018 -12-04 13 :19:24 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/ [ 9609 /9609 ] - gwhaluan.github.io/tech-writing-with-mkdocs/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:24 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/favicon.ico 200 OK unlink: No such file or directory 2018 -12-04 13 :19:24 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/stylesheets/application.451f80e5.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/assets/stylesheets/application.451f80e5.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/javascripts/modernizr.1aa3b519.js 200 OK unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/fonts/material-icons.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/assets/fonts/material-icons.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/stylesheets/hal.css 200 OK gwhaluan.github.io/tech-writing-with-mkdocs/stylesheets/hal.css.tmp: No such file or directory unlink: No such file or directory 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/why/ [ 20913 /20913 ] - gwhaluan.github.io/tech-writing-with-mkdocs/why/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/config/ [ 27062 /27062 ] - gwhaluan.github.io/tech-writing-with-mkdocs/config/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/workflow/ [ 12263 /12263 ] - gwhaluan.github.io/tech-writing-with-mkdocs/workflow/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:25 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/nav/ [ 26665 /26665 ] - gwhaluan.github.io/tech-writing-with-mkdocs/nav/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/link/ [ 11841 /11841 ] - gwhaluan.github.io/tech-writing-with-mkdocs/link/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL:https://gwhaluan.github.io/tech-writing-with-mkdocs/tlpostproc/ [ 9361 /9361 ] - gwhaluan.github.io/tech-writing-with-mkdocs/tlpostproc/index.html.tmp.tmp [ 1 ] 2018 -12-04 13 :19:26 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/assets/javascripts/application.583bbe55.js 200 OK unlink: No such file or directory 2018 -12-04 13 :19:26 URL: https://gwhaluan.github.io/tech-writing-with-mkdocs/scripts/mermaid.min.js 200 OK unlink: No such file or directory https://gwhaluan.github.io/tech-writing-with-mkdocs/link/non-existing.md: Remote file does not exist -- broken link!!! Found 1 broken link. https://gwhaluan.github.io/tech-writing-with-mkdocs/link/non-existing.md FINISHED --2018-12-04 13 :19:26-- Total wall clock time: 2 ,5s Downloaded: 7 files, 115K in 0 ,03s ( 3 ,62 MB/s ) wget needs to be invoked recursively to make it follow any links it discovers during parsing of page contents. The --spider parameter prevents wget from downloading the pages and just behave like a webspider. Note that this causes the log lines prefixed with unlink: , since wget still assumes that there are downloaded files. If we do not exclude the lookup of a robots.txt file with -e robots=off , we get another error 404.","title":"wget"},{"location":"link/#pipeline","text":"You can always run this command locally, but then you would have to do it every time before or after you deploy your changes. Ideally, it would be integrated into the deployment process or be part of your quality control. For instance, wget can be run inside a docker task and even fail your build if there are broken links. In order to not clutter your log, you can hack wget a little via: 2 gt; amp;1 | grep -B 1 ERROR 404 amp; amp; exit 1 || exit 0 This will redirect your stderr also to your stdout, pipe it into grep, looking through it for the string \"ERROR 404\" and then either exit in an error state or not.","title":"Pipeline"},{"location":"nav/","text":"Distributed Navigation Concept If you have a very large project which is rather a collection of documentation projects, you might want to split up your navigation into multiple files and thus split up your mkdocs.yml file. However this is not an option with vanilla mkdocs. Luckily, there is a Plugin option for mkdocs for easy integration of your own code. The yml file format is simple enough to compose a new yml file from a number of sub-yml files more or less directly. For mkdocs, this means that you want to compose the content of the nav -key of your mkdocs.yml file from the nav s in your sub-yml files. To simplify things, i recommend keeping all the yml files you want to compile in the same directory, i.e. in the same directory where mkdocs creates the docs subdirectory: docs |- index.md |- some-other.md |- subdir1 |- index.md |- another.md |- subdir2 |- index.md |- yet-another.md mkdocs.yml ref1.yml ref2.yml It is also handy to separate the documentation projects' Markdown files in subdirectories of docs . Assuming that ref1.yml builds a documentation project in subdir1 and ref2.yml in subdir2 , the nav -keys can look like this: nav : - Home : subdir1/index.md - Some title : subdir1/another.md nav : - Home Two : subdir2/index.md - Some different title : subdir2/yet-another.md Reference ref1.yml and ref2.yml in your mkdocs.yml like so: nav : - Space 1 : ref1.yml - Space 2 : ref2.yml If you use the plugin described below, during your mkdocs build or serve this will be evaluated to: nav : - Space 1 : - Home : subdir1/index.md - Some title : subdir1/another.md - Space 2 : - Home Two : subdir2/index.md - Some different title : subdir2/yet-another.md Code Define a class, and set it up as described in plugin development for mkdocs . Use the on_config method as an entry point, look for your nav -key in the mkdocs.yml file, then iterate through any entries that reference another yml file. For each reference, read that yml-file, and insert its nav -key into the parent file. def on_config ( self , config , ** kwargs ): toc = config [ nav ] self . makeYML ( toc ) def makeYML ( self , toc ): def itertoc ( li ): for i in range ( len ( li )): entry = li [ i ] if ( type ( entry ) is str ): if ( entry . endswith ( .md )): p = os . path . join ( cwd , docs , os . path . normpath ( entry )) # value points to a file if ( os . path . exists ( p ) and os . path . isfile ( p )): tocEntry = {} for line in open ( p ): matchwhite = re . match ( [^\\S \\n ]+ , line ) match = re . match ( #([^#].*) , line ) if matchwhite : continue elif match : tit = match . group ( 1 ) . strip () tocEntry [ tit ] = entry break else : head , tail = os . path . split ( p ) self . logger . debug ( this filename: + tail ) break if ( tocEntry == {}): fnam = os . path . split ( entry )[ 1 ] . split ( . )[ 0 ] tocEntry [ fnam ] = entry li [ i ] = tocEntry else : for k , v in entry . items (): # case value is a list if ( isinstance ( v , type ([]))): entry [ k ] = itertoc ( v ) else : # value is a string p = os . path . join ( cwd , v ) # value points to a file if ( os . path . exists ( p ) and os . path . isfile ( p )): ext = v . split ( . )[ - 1 ] # case value points to a .yml file: load nav -value. if ( ext == ymlExtension ): with open ( p , r ) as stream : data = yaml . load ( stream ) subtoc = data [ nav ] entry [ k ] = ( itertoc ( subtoc )) return li itertoc ( toc ) return I omitted a couple of imports here, notably mkdocs , yaml , sys , os and re .","title":"Solved: Distributed Navigation"},{"location":"nav/#distributed-navigation","text":"","title":"Distributed Navigation"},{"location":"nav/#concept","text":"If you have a very large project which is rather a collection of documentation projects, you might want to split up your navigation into multiple files and thus split up your mkdocs.yml file. However this is not an option with vanilla mkdocs. Luckily, there is a Plugin option for mkdocs for easy integration of your own code. The yml file format is simple enough to compose a new yml file from a number of sub-yml files more or less directly. For mkdocs, this means that you want to compose the content of the nav -key of your mkdocs.yml file from the nav s in your sub-yml files. To simplify things, i recommend keeping all the yml files you want to compile in the same directory, i.e. in the same directory where mkdocs creates the docs subdirectory: docs |- index.md |- some-other.md |- subdir1 |- index.md |- another.md |- subdir2 |- index.md |- yet-another.md mkdocs.yml ref1.yml ref2.yml It is also handy to separate the documentation projects' Markdown files in subdirectories of docs . Assuming that ref1.yml builds a documentation project in subdir1 and ref2.yml in subdir2 , the nav -keys can look like this: nav : - Home : subdir1/index.md - Some title : subdir1/another.md nav : - Home Two : subdir2/index.md - Some different title : subdir2/yet-another.md Reference ref1.yml and ref2.yml in your mkdocs.yml like so: nav : - Space 1 : ref1.yml - Space 2 : ref2.yml If you use the plugin described below, during your mkdocs build or serve this will be evaluated to: nav : - Space 1 : - Home : subdir1/index.md - Some title : subdir1/another.md - Space 2 : - Home Two : subdir2/index.md - Some different title : subdir2/yet-another.md","title":"Concept"},{"location":"nav/#code","text":"Define a class, and set it up as described in plugin development for mkdocs . Use the on_config method as an entry point, look for your nav -key in the mkdocs.yml file, then iterate through any entries that reference another yml file. For each reference, read that yml-file, and insert its nav -key into the parent file. def on_config ( self , config , ** kwargs ): toc = config [ nav ] self . makeYML ( toc ) def makeYML ( self , toc ): def itertoc ( li ): for i in range ( len ( li )): entry = li [ i ] if ( type ( entry ) is str ): if ( entry . endswith ( .md )): p = os . path . join ( cwd , docs , os . path . normpath ( entry )) # value points to a file if ( os . path . exists ( p ) and os . path . isfile ( p )): tocEntry = {} for line in open ( p ): matchwhite = re . match ( [^\\S \\n ]+ , line ) match = re . match ( #([^#].*) , line ) if matchwhite : continue elif match : tit = match . group ( 1 ) . strip () tocEntry [ tit ] = entry break else : head , tail = os . path . split ( p ) self . logger . debug ( this filename: + tail ) break if ( tocEntry == {}): fnam = os . path . split ( entry )[ 1 ] . split ( . )[ 0 ] tocEntry [ fnam ] = entry li [ i ] = tocEntry else : for k , v in entry . items (): # case value is a list if ( isinstance ( v , type ([]))): entry [ k ] = itertoc ( v ) else : # value is a string p = os . path . join ( cwd , v ) # value points to a file if ( os . path . exists ( p ) and os . path . isfile ( p )): ext = v . split ( . )[ - 1 ] # case value points to a .yml file: load nav -value. if ( ext == ymlExtension ): with open ( p , r ) as stream : data = yaml . load ( stream ) subtoc = data [ nav ] entry [ k ] = ( itertoc ( subtoc )) return li itertoc ( toc ) return I omitted a couple of imports here, notably mkdocs , yaml , sys , os and re .","title":"Code"},{"location":"tlpostproc/","text":"Translation Post-Processing Translation of Markdown files is a problem overall. This article takes a look at the problem of translating anchor-links that are generated by mkdocs. In Markdown, you create links with the following syntax: [ Link text ]( relative / path / to / file . md # anchor ) The problem is, when the section titles are translated, the anchor links no longer work, since they target the titles. The links would have to be translated as well. Since the #anchor part of the link is processed by Markdown in a way that is not obvious to the user (lowercase and normalization of special characters), this could be really hard for translators to get right. A workaround would be the use of custom anchor labels . In file.md you can then define an anchor like ## Anchor { #anchor} and keep referencing the anchor label. This can even be automated so that Markdown files are translated, and in a post-processing step that compares the original version and the translated version the anchor labels for the translated section titles will be generated from the original anchor texts.","title":"Idea: Translation Post-Processing"},{"location":"tlpostproc/#translation-post-processing","text":"Translation of Markdown files is a problem overall. This article takes a look at the problem of translating anchor-links that are generated by mkdocs. In Markdown, you create links with the following syntax: [ Link text ]( relative / path / to / file . md # anchor ) The problem is, when the section titles are translated, the anchor links no longer work, since they target the titles. The links would have to be translated as well. Since the #anchor part of the link is processed by Markdown in a way that is not obvious to the user (lowercase and normalization of special characters), this could be really hard for translators to get right. A workaround would be the use of custom anchor labels . In file.md you can then define an anchor like ## Anchor { #anchor} and keep referencing the anchor label. This can even be automated so that Markdown files are translated, and in a post-processing step that compares the original version and the translated version the anchor labels for the translated section titles will be generated from the original anchor texts.","title":"Translation Post-Processing"},{"location":"why/","text":"Why mkdocs? There are many ways to organize your Technical Writing. What it comes down to, is your specific use case. When i started my last job, the situation was this: We wanted to provide useful user documentation There were many Word documents that were or were not up to date Confluence and Scroll Viewport were proposed as a solution Some effort had been done to implement this, mostly text conversion from Word to Confluence We decided against Confluence and used Markdown and mkdocs instead. Our reasons were: Confluence and most of its plugins are proprietary and WYSIWYG For business reasons, we did not have direct control over Scroll Viewport styling There was no link between Confluence and the software release process We saw a major gap to our software development as developers disliked using Confluence Pipeline and deployment tools were already in use in the development teams Markdown is simple and therefore easily customizable and portable Features Plain Text Source Markdown is an easy to pick up simple markup language and thus in plain text format. Writing texts in plain text format is an advantage because you store and maintain information on how it is displayed separately. Theming and Styling via mkdocs mkdocs has a number of more or less well-designed themes. You can alter them to your liking. Please refer to my recommended mkdocs setup for more information. Easy Collaboration Due to its plain text nature, you can easily work with a version-control software such as git. Collaboration and reviewing are quite easy that way, and comparable to the maintenance of software code. Checkout docs as code . Problems Static Explicit Navigation Your mkdocs navigation is maintained in the mkdocs.yml file. For complete control, you need to reference every Markdown file that you want to be part of your documentation. You can have Markdown infer the navigation title from the h1 headline of a Markdown file, or override it in your mkdocs.yml file: nav : - Home : index.md - config.md In this example, the navigation entry Home is explicit in the mkdocs.yml file, while the navigation entry for the configuration article is inferred from the h1 headline in the file config.md . There are some problems with such inferences and the state of nested navigation siblings, see mkdocs issue #1347 . In my solution sketched out in the article about distributed navigation , there is a built-in solution for this problem as well. Encoding TODO Software Variants and Versions With a comprehensive mkdocs setup, you are likely using a number of software packages that can all have different versions and that might clash with eachother. I cannot recommend keeping everything up to date. For example, the Markdown software is incompatible with markdown_include since the 3.0 release of Markdown . In order to keep things compatible, you need to deliberately use version 2.6.11. Multi-Language Support There is no multi-language support for mkdocs currently. Possible solutions and discussions about them are scarce and mostly open issues of the project (eg issue #614 ). For a translation workflow you would need to either translate Markdown files and yml files or the mkdocs-generated HTML files. The Markdown format can be problematic. In order to have a clean translation, language-specific hosting could work, i.e. to have a sub-project per language that is structurally equivalent to what you have translated. Large Search Index in Large Projects The built-in mkdocs search is problematic to say the least. It uses lunr.js and parses all documentation pages into a search index. This index is then queried when a user enters a search term into the search bar. The way it was implemented up to milestone release 1.0 , the search index was parsed every time the user entered a search term on a specific page. This means, whenever the user navigated to a different page and then used the search bar again, unnecessary index parsing occured. This is still the case if you use the Material theme for mkdocs, as it overrides the improved search that was released in 1.0. For a larger documentation project (we had around 1200 pages), the search index is substantially large (60mb+) to slow down parsing a lot. This meant that the search bar was unusable, since it blocked the GUI for several seconds upon use. If Material didn't override the search, it would be usable by now. However, I recommend not using the Javascript search at all but instead implement your own server-side search.","title":"Why mkdocs?"},{"location":"why/#why-mkdocs","text":"There are many ways to organize your Technical Writing. What it comes down to, is your specific use case. When i started my last job, the situation was this: We wanted to provide useful user documentation There were many Word documents that were or were not up to date Confluence and Scroll Viewport were proposed as a solution Some effort had been done to implement this, mostly text conversion from Word to Confluence We decided against Confluence and used Markdown and mkdocs instead. Our reasons were: Confluence and most of its plugins are proprietary and WYSIWYG For business reasons, we did not have direct control over Scroll Viewport styling There was no link between Confluence and the software release process We saw a major gap to our software development as developers disliked using Confluence Pipeline and deployment tools were already in use in the development teams Markdown is simple and therefore easily customizable and portable","title":"Why mkdocs?"},{"location":"why/#features","text":"","title":"Features"},{"location":"why/#plain-text-source","text":"Markdown is an easy to pick up simple markup language and thus in plain text format. Writing texts in plain text format is an advantage because you store and maintain information on how it is displayed separately.","title":"Plain Text Source"},{"location":"why/#theming-and-styling-via-mkdocs","text":"mkdocs has a number of more or less well-designed themes. You can alter them to your liking. Please refer to my recommended mkdocs setup for more information.","title":"Theming and Styling via mkdocs"},{"location":"why/#easy-collaboration","text":"Due to its plain text nature, you can easily work with a version-control software such as git. Collaboration and reviewing are quite easy that way, and comparable to the maintenance of software code. Checkout docs as code .","title":"Easy Collaboration"},{"location":"why/#problems","text":"","title":"Problems"},{"location":"why/#static-explicit-navigation","text":"Your mkdocs navigation is maintained in the mkdocs.yml file. For complete control, you need to reference every Markdown file that you want to be part of your documentation. You can have Markdown infer the navigation title from the h1 headline of a Markdown file, or override it in your mkdocs.yml file: nav : - Home : index.md - config.md In this example, the navigation entry Home is explicit in the mkdocs.yml file, while the navigation entry for the configuration article is inferred from the h1 headline in the file config.md . There are some problems with such inferences and the state of nested navigation siblings, see mkdocs issue #1347 . In my solution sketched out in the article about distributed navigation , there is a built-in solution for this problem as well.","title":"Static Explicit Navigation"},{"location":"why/#encoding","text":"TODO","title":"Encoding"},{"location":"why/#software-variants-and-versions","text":"With a comprehensive mkdocs setup, you are likely using a number of software packages that can all have different versions and that might clash with eachother. I cannot recommend keeping everything up to date. For example, the Markdown software is incompatible with markdown_include since the 3.0 release of Markdown . In order to keep things compatible, you need to deliberately use version 2.6.11.","title":"Software Variants and Versions"},{"location":"why/#multi-language-support","text":"There is no multi-language support for mkdocs currently. Possible solutions and discussions about them are scarce and mostly open issues of the project (eg issue #614 ). For a translation workflow you would need to either translate Markdown files and yml files or the mkdocs-generated HTML files. The Markdown format can be problematic. In order to have a clean translation, language-specific hosting could work, i.e. to have a sub-project per language that is structurally equivalent to what you have translated.","title":"Multi-Language Support"},{"location":"why/#large-search-index-in-large-projects","text":"The built-in mkdocs search is problematic to say the least. It uses lunr.js and parses all documentation pages into a search index. This index is then queried when a user enters a search term into the search bar. The way it was implemented up to milestone release 1.0 , the search index was parsed every time the user entered a search term on a specific page. This means, whenever the user navigated to a different page and then used the search bar again, unnecessary index parsing occured. This is still the case if you use the Material theme for mkdocs, as it overrides the improved search that was released in 1.0. For a larger documentation project (we had around 1200 pages), the search index is substantially large (60mb+) to slow down parsing a lot. This meant that the search bar was unusable, since it blocked the GUI for several seconds upon use. If Material didn't override the search, it would be usable by now. However, I recommend not using the Javascript search at all but instead implement your own server-side search.","title":"Large Search Index in Large Projects"},{"location":"workflow/","text":"Workflows Review Deployment Of course you need to host your documentation somewhere. Pipeline github pages","title":"Workflows"},{"location":"workflow/#workflows","text":"","title":"Workflows"},{"location":"workflow/#review","text":"","title":"Review"},{"location":"workflow/#deployment","text":"Of course you need to host your documentation somewhere.","title":"Deployment"},{"location":"workflow/#pipeline","text":"","title":"Pipeline"},{"location":"workflow/#github-pages","text":"","title":"github pages"}]}